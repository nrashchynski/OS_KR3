# Поведенческие шаблоны проектирования на C++

В этом проекте реализованы три классических **поведенческих шаблона проектирования**:

1. [Команда (Command)](#-команда-command)
2. [Стратегия (Strategy)](#-стратегия-strategy)
3. [Шаблонный метод (Template Method)](#-шаблонный-метод-template-method)

Файлы с реализациями находятся в папке [`examples/`](./examples).

---

## Общая идея шаблонов

| Шаблон             | Ключевая идея                        | Главная польза                         |
|--------------------|--------------------------------------|----------------------------------------|
| **Command**        | Команды как объекты                 | Отложенный запуск, отмена, логирование |
| **Strategy**       | Поведение как объект                | Гибкая замена алгоритмов               |
| **TemplateMethod** | Скелет алгоритма в базовом классе  | Повторное использование структуры      |

---


## Команда (Command)

 `examples/command/command_example.cpp`

### Что делает:

- Есть объект `Light` с методами `turnOn()` и `turnOff()`.
- Каждое действие — это класс-команда (`TurnOnCommand`, `TurnOffCommand`).
- Класс `RemoteControl` накапливает команды и вызывает их.

```cpp
remote.setCommand(new TurnOnCommand(lamp));
remote.runCommands();
```

### Зачем это нужно:
Позволяет отвязать того, кто вызывает команду, от того, кто её выполняет

Команды можно логировать, откладывать, отменять

## Стратегия (Strategy)
 examples/strategy/strategy_example.cpp

###  Что делает:
Есть интерфейс PaymentStrategy

Есть реализации: PayByCard, PayByCash

Класс Order принимает стратегию оплаты и использует её

```cpp
order.setStrategy(new PayByCard());
order.checkout(250);
```
###  Зачем это нужно:
Избавляет от if/else/switch

Позволяет менять поведение "на лету"

## Шаблонный метод (Template Method)
 examples/template_method/template_method_example.cpp

### Что делает:
Базовый класс ReportGenerator содержит общий алгоритм generate()

Подклассы (SalesReport, InventoryReport) реализуют отдельные шаги

``` cpp
Копировать код
report->generate(); // вызывает: fetchData → processData → exportReport
``` 

### Зачем это нужно:
Убирает дублирование общей логики

Позволяет подклассам менять отдельные шаги, не ломая структуру
